{"version":3,"file":"static/js/873.e103cb57.chunk.js","mappings":"8PAGaA,EAAiB,mCAAG,WAAMC,GAAN,0EAC1BA,EAD0B,yCAEtB,MAFsB,gCAKNC,EAAAA,EAAAA,IAAA,6CACiBD,EADjB,oBAPf,qCAEqB,cAKvBE,EALuB,yBAQtBA,EAASC,MARa,gCAU7BC,QAAQC,IAAR,wBAV6B,yDAAH,sD,SC4D9B,EA1DqB,WAAO,IAAD,IACnBC,GAAWC,EAAAA,EAAAA,MACXC,EAAY,oBAAGF,EAASG,aAAZ,aAAG,EAAgBC,YAAnB,QAA2B,IACrCC,GAAYC,EAAAA,EAAAA,MAAZD,QACR,GAA0BE,EAAAA,EAAAA,UAAS,MAAnC,eAAOC,EAAP,KAAcC,EAAd,KACA,GAA8BF,EAAAA,EAAAA,WAAS,GAAvC,eAAOG,EAAP,KAAgBC,EAAhB,KAcA,OAZAC,EAAAA,EAAAA,YAAU,WACR,IAAMC,EAAU,mCAAG,oGACOpB,EAAkBY,GADzB,QACXS,EADW,SAGfL,EAASK,GAEXH,GAAW,GALM,2CAAH,qDAOhBE,GACD,GAAE,CAACR,EAASK,IAEbZ,QAAQC,IAAIC,IAEV,8BACGU,GACC,yCACEF,GACF,4BACE,gBACEO,IAAG,yCAAoCP,EAAMQ,YAA1C,KACHC,IAAI,SAEN,SAAC,KAAD,CAAMC,GAAIhB,EAAV,sBACA,oCAAYM,EAAMW,UAClB,wCAAgBC,KAAKC,KAA0B,GAArBb,EAAMc,cAAhC,QACA,sCACA,uBAAId,EAAMe,YACV,oCAEA,wBACGf,EAAMgB,QACLhB,EAAMgB,OAAOC,KAAI,SAAAC,GACf,OAAO,wBAAoBA,EAAWC,MCzBlC,eAACC,EAAD,uDAAQ,GAAR,OAClBC,OAAOC,gBAAgB,IAAIC,WAAWH,IAAOI,QAAO,SAACtC,EAAIuC,GAWvD,OAREvC,IAFFuC,GAAQ,IACG,GACHA,EAAKC,SAAS,IACXD,EAAO,IACTA,EAAO,IAAIC,SAAS,IAAIC,cACtBF,EAAO,GACV,IAEA,IAGT,GAAE,GAbe,CDyBYG,GACjB,OAEL,sDACA,SAAC,KAAD,CAAMlB,GAAG,OAAOf,MAAO,CAAEC,KAAMF,GAA/B,mBAGA,SAAC,KAAD,CAAMgB,GAAG,UAAUf,MAAO,CAAEC,KAAMF,GAAlC,sBAGA,SAAC,KAAD,QAGF,8DAIP,C","sources":["utils/fetchMovieDetails.js","components/MovieDetails/MovieDetails.jsx","../node_modules/nanoid/index.browser.js"],"sourcesContent":["import axios from 'axios';\nconst KEY = '65128993e18cf258695ad7fce6893761';\n\nexport const fetchMovieDetails = async id => {\n  if (!id) {\n    return null;\n  }\n  try {\n    const response = await axios.get(\n      `https://api.themoviedb.org/3/movie/${id}?api_key=${KEY}`\n    );\n    return response.data;\n  } catch (error) {\n    console.log(`Error: ${error}`);\n  }\n};\n","import { useState, useEffect } from 'react';\nimport { useParams, Outlet, Link, useLocation } from 'react-router-dom';\nimport { nanoid } from 'nanoid';\nimport { fetchMovieDetails } from '../../utils/fetchMovieDetails';\n\nconst MovieDetails = () => {\n  const location = useLocation();\n  const backLinkHref = location.state?.from ?? '/';\n  const { movieId } = useParams();\n  const [movie, setMovie] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const movieFetch = async () => {\n      const movieData = await fetchMovieDetails(movieId);\n      if (movieData) {\n        setMovie(movieData);\n      }\n      setLoading(false);\n    };\n    movieFetch();\n  }, [movieId, loading]);\n\n  console.log(location);\n  return (\n    <>\n      {loading ? (\n        <div>Loading... </div>\n      ) : movie ? (\n        <div>\n          <img\n            src={`https://image.tmdb.org/t/p/w500${movie.poster_path} `}\n            alt=\"cze\"\n          />\n          <Link to={backLinkHref}>Go back</Link>\n          <h2>Title: {movie.title}</h2>\n          <p>User Score: {Math.ceil(movie.vote_average * 10)}%</p>\n          <h3>Overview</h3>\n          <p>{movie.overview}</p>\n          <h3>Genres</h3>\n\n          <ul>\n            {movie.genres &&\n              movie.genres.map(movieGenre => {\n                return <li key={nanoid()}>{movieGenre.name}</li>;\n              })}\n          </ul>\n          <span>Additional information</span>\n          <Link to=\"cast\" state={{ from: backLinkHref }}>\n            Cast\n          </Link>\n          <Link to=\"reviews\" state={{ from: backLinkHref }}>\n            Reviews\n          </Link>\n          <Outlet />\n        </div>\n      ) : (\n        <div>There is no movie with this id!</div>\n      )}\n    </>\n  );\n};\n\nexport default MovieDetails;\n","export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n"],"names":["fetchMovieDetails","id","axios","response","data","console","log","location","useLocation","backLinkHref","state","from","movieId","useParams","useState","movie","setMovie","loading","setLoading","useEffect","movieFetch","movieData","src","poster_path","alt","to","title","Math","ceil","vote_average","overview","genres","map","movieGenre","name","size","crypto","getRandomValues","Uint8Array","reduce","byte","toString","toUpperCase","nanoid"],"sourceRoot":""}